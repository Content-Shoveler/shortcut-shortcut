import React, { createContext, useContext, ReactNode, useCallback } from 'react';
import { cacheStorage } from '../services/storage/CacheStorage';

// Interface for the cache context
interface CacheContextType {
  getCache: (key: string) => any | null;
  setCache: (key: string, data: any, ttl?: number) => void;
  invalidateCache: (keyPattern?: string) => void;
  clearCache: () => void;
  getCacheKeys: () => string[];
}

// Default TTL values (in milliseconds)
const DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes
const STATIC_DATA_TTL = 30 * 60 * 1000; // 30 minutes
const DYNAMIC_DATA_TTL = 2 * 60 * 1000; // 2 minutes

// Create the context with default values
const CacheContext = createContext<CacheContextType>({
  getCache: () => null,
  setCache: () => {},
  invalidateCache: () => {},
  clearCache: () => {},
  getCacheKeys: () => [],
});

// Hook for using the cache context
export const useCache = () => useContext(CacheContext);

// The TTL configuration based on endpoint patterns
const getTtlForKey = (key: string): number => {
  // More static data types
  if (key.includes('projects') || 
      key.includes('workflows') || 
      key.includes('epic-workflow') || 
      key.includes('members')) {
    return STATIC_DATA_TTL;
  }
  
  // More dynamic data types
  if (key.includes('iterations') || 
      key.includes('states') || 
      key.includes('labels')) {
    return DYNAMIC_DATA_TTL;
  }
  
  // Default TTL for everything else
  return DEFAULT_TTL;
};

// The CacheProvider component
interface CacheProviderProps {
  children: ReactNode;
}

export const CacheProvider: React.FC<CacheProviderProps> = ({ children }) => {
  // Get data from cache if it exists and hasn't expired
  const getCache = useCallback(async (key: string): Promise<any | null> => {
    if (!key) return null;
    
    return await cacheStorage.getCache(key);
  }, []);

  // Store data in the cache with a TTL
  const setCache = useCallback(async (key: string, data: any, customTtl?: number): Promise<void> => {
    if (!key) return;
    
    // Calculate TTL based on the key or use custom TTL if provided
    const ttl = customTtl || getTtlForKey(key);
    
    await cacheStorage.setCache(key, data, ttl);
  }, []);

  // Invalidate cache entries that match a key pattern
  const invalidateCache = useCallback(async (keyPattern?: string): Promise<void> => {
    if (!keyPattern) return; // If no pattern provided, do nothing
    
    await cacheStorage.invalidateCache(keyPattern);
  }, []);

  // Clear the entire cache
  const clearCache = useCallback(async (): Promise<void> => {
    await cacheStorage.clearCache();
  }, []);

  // Get all current cache keys (useful for debugging)
  const getCacheKeys = useCallback((): string[] => {
    return cacheStorage.getCacheKeys();
  }, []);

  // Create a synchronous wrapper around the async functions
  // This maintains backward compatibility with the existing API
  const syncGetCache = useCallback((key: string): any | null => {
    // For now, we'll return null and log a warning
    // In a full implementation, we would need to make components that use this
    // handle the async nature, but that's a larger refactoring
    console.warn(`getCache for ${key} is now asynchronous and should be used with await`);
    
    // Kick off the async operation but don't wait for it
    getCache(key).then(data => {
      console.log(`Cache for ${key} is now available asynchronously`);
    }).catch(error => {
      console.error(`Error getting cache for ${key}:`, error);
    });
    
    return null;
  }, [getCache]);

  const syncSetCache = useCallback((key: string, data: any, customTtl?: number): void => {
    // Kick off the async operation but don't wait for it
    setCache(key, data, customTtl).catch(error => {
      console.error(`Error setting cache for ${key}:`, error);
    });
  }, [setCache]);

  const syncInvalidateCache = useCallback((keyPattern?: string): void => {
    // Kick off the async operation but don't wait for it
    invalidateCache(keyPattern).catch(error => {
      console.error(`Error invalidating cache for pattern ${keyPattern}:`, error);
    });
  }, [invalidateCache]);

  const syncClearCache = useCallback((): void => {
    // Kick off the async operation but don't wait for it
    clearCache().catch(error => {
      console.error('Error clearing cache:', error);
    });
  }, [clearCache]);

  return (
    <CacheContext.Provider 
      value={{ 
        getCache: syncGetCache, 
        setCache: syncSetCache, 
        invalidateCache: syncInvalidateCache, 
        clearCache: syncClearCache, 
        getCacheKeys 
      }}
    >
      {children}
    </CacheContext.Provider>
  );
};
